  <div class="details__content row">
    <div class="col-lg-2 col-md-0"></div>
    <div class="col-lg-4 col-md-12">
      <h2 class="details__heading">
        <span class="details__heading--building">Building</span>{~s}
        <span class="details__heading--modern">the modern</span>{~s}
        <span class="details__heading--client">web client</span>
      </h2>
    </div>
    <div class="col-lg-4 col-md-12 details__body">
      <h3 class="details__model-heading">Steps Forward.</h3>
      <p>
        With ever growing  browser support for html5 standards and the advent of the modern JavaScript ecosystem, it now possible to build web applications that can operate as more than an extension and convenient enhancement to the server. The modern web client can render its own ui, enforce its own business logic, communicate with a large range of services, and in general provide a more responsive user experience that is closer in feel to a native application than a web page. This change in paradigm has transformed the basic nature of the font - end / ui developer role and disrupted the division of responsibilities within the development team.
      </p>
    </div>
      <div class="col-lg-2 col-md-0"></div>
    </div>
    <div class="details__content row">
      <div class="col-lg-2  col-md-0"></div>
      <div class="col-lg-8 col-md-12 details__body">
      <p>
          It is fair to say the role of ui developer is relatively new and has a definition that may still be in flux. In the past, front-end development tasks were simple enough that they were often distributed amongst, or tacked on to, other roles. The designer may create some styling or ui implementations (often generated by design applications such as Dreamweaver), or the server-side application developer might write some JavaScript on top of their other responsibilities. The front-end existed in a sort of ambiguous gray area positioned  between ux/designers on one end and back-end developers on the other.  Over time there emerged a need for a specialist that would focus on hand writing css and creating custom JavaScript that would produce a more functional UI while generating a more maintainable code base.  But the perception that the “serious”, “mission critical” code lives on the server and the front end is essentially disposable is still all too common in the industry.
        </p>
        <p>
          While server side technologies are very mature at this point and their role is more or less well defined, front end technologies have been in a period of rapid growth and development for years now. It is understandable that management is unclear on the role and a capabilities of this new technology and how it fit into the their current stack.  However, the UI technologies have started to solidify and the value proposition of a client oriented, self contained, front-end stack is beginning to become evident.  We have the tools, technologies and the opportunity to develop this new web client that is growing in robustness and continuing to deliver  better, more responsive experiences to the user.  But to capitalize on this shift I believe the UI must be treated with the same seriousness and dedication that is given to sever centered applications currently.  Operating with the old model were the server is the center of all concerns is going to become less and less feasible as user expectations continue to grow.  The client is becoming one of the primary pillars of the next generation of web based applications, no more or less important than any other pillar. I believe this philosophy provides an opportunity (with many complimentary challenges, of course) to advance the experience of using the web for the end user in a palpable way.
      </p>
    </div>
    <div class="col-lg-2  col-md-0"></div>
  </div>
  <hr class="details__rule">
  <div class="details__content row">
    <div class="col-lg-2  col-md-0 col-xs-0"></div>
    <div class="col-lg-8 col-md-12 details__body">
      <h3 class="details__model-heading">The Client Application Stack</h3>
      <div class="details__col">
        <p>
          Visualizing a new way of thinking about the applications stack were the client has more responsibility is not an entirely simple task. There are so many technologies involved that creating a visualization can easily get unwieldy and become pretty useless. I have done my best to simplify a concept of a basic architecture. Take it for what it is, a concept, not a blueprint.
        </p>
        <p>
          The server is still responsible for sending the initial html page to the browser as it must. The page may contain a basic mount point for the front end application or there may be a need for an initial server side rendering for SEO reasons. There is a strong argument to be made for doing an initial render server side, or doing the app rendering in a middle-ware layer running node.js server. It allows the page to display initial content before the JavaScript application is downloaded and initialized. This can give the perception to the user that the app has loaded faster. It is also likely the server would be embedding initial bootstrap data for the application to avoid any immediate additional data requests &mdash; also a nice optimization. Ideally, at this point, the server (or middle-ware) is done producing html. Additional domain interactions would be in the form of api requests using whatever standard is appropriate: REST, SOAP, GraphQL &mdash; whatever the overriding architecture demands.  In the case of an authenticated application, these domain services would also still maintain the session by checking request headers and responding as appropriate when a session expires.
        </p>
        <p>
          Once an application has been bootstrapped onto the page it can then use its own internal data store to maintain its state and respond to user interactions, internal events, or subscribed stream events (in the case of the <a href="https://github.com/Reactive-Extensions/RxJS">reactive model</a> -- something I am very excited to learn more about).  The diagram illustrates a data flow that is essentially the <a href="https://facebook.github.io/flux/">Flux</a> pattern were data flows in a single direction. An application event (or <a href="http://redux.js.org/docs/basics/Actions.html">Action</a> ) causes a change in application state which in turn causes the application to re-render its display. Data flows down to the store through event handlers and the state is manipulated there (or a new state is produced if the state is immutable).  The store responsible for transforming the state and passing it back to the view engine.
        </p>
        <p>
          Bellow the state layer I have placed the somewhat generic concept of the model. The model is a placeholder for the connection layer that handles making the api requests, or subscribes to event streams using  XMLHttpRequest, Fetch or even WebSockets.  It also needs to provide an interface to the store for dealing with asynchronous behavior using something like events, promises, callbacks, generators (<a href="http://stackoverflow.com/questions/28489988/svg-takes-up-too-much-space">sagas</a>s&gt;), or observables. This is were the connection to the back-end or other services is handled. Additionally the model could provide additional functions related to the data such as hydration of a data set, aggregation of multiple requests, or transformation from a service schema to something more easily digest-able by the store. Every layer above the model is unaware of any specifics regarding details of communication protocols, only the interface provided by the model -- making swapping the model code out with a different implementation without affecting the code in layer above theoretically possible.
        </p>
        <p>
          Because of the possibility for data transformation at the model level I have also marked the model as a layer that could be hosted on a node.js middle-ware server. Most of the discussion these day about server hosted javascript middle-layers center around doing an initial render on the server as I mentioned above.  Even if pre-rendering is the use-case with the most obvious benefits I believe the middle-layer can have a place in the service connection. It is essentially a layer between the client and the application server for api communication. It is certainly a more complex process than a direct service call from the client and there would be concerns in terms of network latency, scaling and timeouts. But under the right circumstances it does have the potential benefits of offloading some of the data processing  to a more predictable environment and optimizing the transfer payload between the middle-layer and client.  Not all users have the benefit of a fast device on a fast network, so having the capability to optimize for slower clients without touching the primary (potentially legacy) service api could be very valuable.
        </p>
        <dv class="details__model">
          {>"app/dust/svg/ui-model" /}
        </dv>
      </div>
    </div>
  </div>
    <div class="col-lg-2  col-md-0 col-xs-0"></div>
  </div>
  <div class="col-lg-2 col-md-0 col-xs-0"></div>
</div>
<div class="details__arrow">
   <a class="arrow fa fa-arrow-down fa-2x bounce" href="#tech"></a>
</div>