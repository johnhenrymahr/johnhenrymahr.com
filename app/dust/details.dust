  <article>
  <div class="details__content row">
    <div class="col-lg-2 col-md-0"></div>
    <div class="col-lg-4 col-md-12">
      <h2 class="details__heading">
        <span class="details__heading--building">Building</span>{~s}
        <span class="details__heading--modern">the modern</span>{~s}
        <span class="details__heading--client">web client</span>
      </h2>
    </div>
    <div class="col-lg-4 col-md-12 details__body">
      <h3 class="details__model-heading">Steps Forward.</h3>
      <p>
        With ever growing  browser support for html5 standards and the advent of the modern JavaScript ecosystem, it now possible to build web applications that can operate as more than just a skin for a server driven application. The modern web client brings its own independent application architecture to the table allowing for enforcement of business logic, input validation, user preferences, and user flows without constantly deferring to a server application that sits on the other side of a Internet connection that may be inconsistent, slow or unstable.  A new level of responsive user experience that is much closer in feel to a native application is now possible while retaining the open, cross platform advantages of a web application. This change in paradigm from a server centric model to one where the client has a larger role has transformed the basic nature of the Font - End / UI Developer role and disrupted the division of responsibilities within the development team.
      </p>
    </div>
      <div class="col-lg-2 col-md-0"></div>
  </div>
  <div class="details__content row">
      <div class="col-lg-2  col-md-0"></div>
      <div class="col-lg-8 col-md-12 details__body">
       <figure>
          <div>
            {>"app/dust/svg/ui-role" /}
          </div>
          <figcaption>
          The role of the UI Developer within the continuum from humanistic concerns to technological concerns. With credit and much thanks given to <a href="https://asinthecity.com/2011/11/10/the-difference-between-a-ux-designer-and-ui-developer/" target="_BLANK"> this blog article.</a>
          </figcaption>
      </figure>
      <h3 class="details__model-heading">The role of the UI Developer</h3>
      <p>
          The UI Developer role sits in an unique position on the development team.  In a sense, the UI Developer must be the bridge between two very different worlds and ways of thinking. On the one side are the user focused, “soft” (in a sense of be less definable by nature) concerns of UX: usability, interaction design and visual impact. And on the other, the technological focused, “hard” concerns of the application developer: api efficiency, security, versioning, separation of concerns, and performance.  A good UI Developer must at least have an “eye” for design and what looks good, a sense of when a user experience is or is not working on the one hand, and on the other hand also have strong coding skills, an ability to troubleshoot and debug across environments, and manage a build infrastructure.  And on top of this the UI Developer often ends up being one of the primary advocates and implementors of accessibility on the team.  So it requires a developer who is at least somewhat comfortable in UX/Design application such as Photoshop, Sketch or Illustrator as well as the primary skill set of writing JavaScript, CSS [or Less, Sass, Stylus…] or HTML in an editor or IDE, or logging  into a Linux server and modifying an Apache or NGINX configuration file in vi. A good UI Developer needs to embrace these various aspects with a strong curiosity about how things work, how they can be improved and most importantly must posses a fearlessness to jump in and work with technologies, comprehend standards or tackle problems that they may have never encountered before.  They need to be, at a minimum, aware of nearly every aspect of the web page, and whenever possible, understand the technical considerations, specifications and general best practices that underly and define those aspects.
        <p>
          Unfortunately, despite of all these varied skills and requirements, the UI developer is often in a position of justifying the significance of their role and the value they offer — especially in an enterprise environment.  While server side technologies are very mature at this point and their role, infrastructure and processes are more or less well defined and their value is obviously paramount; front end technologies present a value proposition that is less clear. It is understandable, considering  the period of rapid growth, development, and radical change that Front End technology has recently been going through, that management or leadership is often unclear of the scope of work, skill sets required, and complexities involved when implementing these technologies and how those challenges relate to the performance and efficiency of the rest of their current stack. There is a temptation perhaps to stick with what has worked and been proven up to this point and not evolve the stack to leverage these new UI technologies. However, the web in general, and more importantly user expectations of how the web should work, are evolving. Users are beginning to expect a more robust, “app” like, experience, and are beginning to loose patience with applications that make them wait those extra milliseconds for the extra round trips to the server for every action. We now have the tools, technologies and the opportunity to deliver that  robust and responsive user interface.  But to fulfill this potential I believe the UI must be treated with the same seriousness and dedication that is given to server centered applications currently.  Operating with the old model — where the server is the center of all concerns and the UI is a minor implementation detail — is going to become less and less feasible as the general shift towards a “thicker” client continues.  The client is becoming one of the primary pillars of the next generation of web based applications, no more or less important than any other pillar. It is time to move outside of the comfort zone and let the UI take its place along side those other pillars of the the technology stack.
      </p>
    </div>
    <div class="col-lg-2  col-md-0"></div>
  </div>
  <div class="details__content row">
    <div class="col-lg-2  col-md-0 col-xs-0"></div>
    <div class="col-lg-8 col-md-12 details__body">
      <h3 class="details__model-heading">Getting Serious</h3>
      <p>
        To be clear. This is not a concept but something that is already well underway. There are many companies and development teams that are already implementing robust client side applications. Additionally, all of the Browser vendors are relentlessly pushing browser technology forward at a pace never before seen providing the essential foundations for the client of the future. Service workers, local storage, web sockets, server sent events, flex-box, HTTP version 2, and now even web assembly — to name just a few (see <a href="http://www.evolutionoftheweb.com" target="_BLANK">this</a> for a visual representation that is quite fun.) As always with the web, just keeping up and not being totally left behind is the real task. And right now is the age of the client. That is why it is time to get serious about UI development and to give it the attention it needs.  UI development needs proper code review, real oversight, security auditing, performance testing and, more than anything, to be part of the discussion when it comes to architectural planning and decisions. If we can do that I think the opportunities for advancing the web experience are tremendous.
      </p>
      </div>
      <div class="col-lg-2  col-md-0 col-xs-0"></div>
  </div>
</article>
  <hr class="details__rule">
  <article>
  <div class="details__content row">
    <div class="col-lg-2  col-md-0 col-xs-0"></div>
    <div class="col-lg-8 col-md-12 details__body">
      <h3 class="details__model-heading"><em>In Depth:</em> The Client Application Stack</h3>
        <div class="details__col">

          <blockquote class="blockquote text-center">
            <p class="blockquote__body"><span class="bigquote">“</span>No bit is faster than one that is not sent; send fewer bits.<span class="bigquote">”</span></p>
            <footer class="blockquote-footer">
              <strong>Ilya Grigorik</strong> on Tuning Application Behavior
              <cite title="High Performance Browser Networking"><a href="https://hpbn.co/">High Performance Browser Networking</a></cite>
            </footer>
          </blockquote>

          <p>
            How does this new, more robust UI layer fit into the greater web application technology stack? It is not a question that can really be answered in a generic way.  Every business need, architecture and technology stack has its own set of requirements and special challenges. But lets try anyways — because its fun! The following is one concept of how it might work.  There are so many technologies involved that creating a visualization can easily get unwieldy and become pretty useless. I have done my best to simplify a basic idea about a architecture were the UI layer is more independent of the server. These are broad strokes for the sake of argument and discussion.
          </p>
          <figure>
            <div>
              {>"app/dust/svg/ui-model" /}
            </div>
            <figcaption>A simple example of a client application stack.</figcaption>
          </figure>
          <p>
            Of course it all begins with the client making a http request to the web server of some sort and receiving a response body containing an html document. The page may contain a basic mount point (DOM element container) for the front end application to be injected into or there may be a need for an initial server side rendering for SEO reasons. There is a strong argument to be made for doing an initial render server side, or doing the app layout rendering in a middle-ware layer running node.js server. It allows the page to display initial content before the JavaScript application has been downloaded and initialized. This can give the perception to the user that the app has loaded faster. It is also likely the server would be embedding initial bootstrap data for the application to avoid any immediate additional data requests —  also a nice optimization. Ideally, at this point, the server (or middle-ware) is done producing html. Additional domain interactions would be in the form of api requests using whatever standard is appropriate: REST, SOAP, GraphQL — whatever the overriding architecture demands.  In the case of an authenticated application, these domain services would also still maintain the session by checking request headers and responding as appropriate when a session expires.
          </p>
          <aside>
            <p>
                <strong>Why node.js for middle ware?</strong>
            </p>
            <p>
              Sure, any language could be used for a middle ware layer. Node.js (or some other JavaScript based server in theory) allows for re-use of client side assets in a server context, be it a react application or js template.  Implementing and maintaining the same asset in multiple languages or frameworks tends to get messy very fast.
            </p>
          </aside>
          <p>
            Once an application has been bootstrapped onto the page it can then use its own internal data store to maintain its state and respond to user interactions, internal events, or subscribed stream events (in the case of the <a href="https://github.com/Reactive-Extensions/RxJS" target="_BLANK">reactive model</a> -- something I am very excited to learn more about).  The diagram illustrates a data flow that is essentially the <a href="https://facebook.github.io/flux/" target="_BLANK">Flux</a> pattern were data flows in a single direction. An application event (or <a href="http://redux.js.org/docs/basics/Actions.html" target="_BLANK">Action</a> ) causes a change in application state which in turn causes the application to re-render its display. Data flows down to the store through event handlers and the state is mutated there (or a new state is produced if the state is immutable).  The store is responsible for transforming the state and passing it back to the view engine.
          </p>
          <p>
            Bellow the state layer I have placed the somewhat generic concept of the model. The model is a placeholder for the connection layer that handles making the api requests, or subscribes to event streams using  XMLHttpRequest, Fetch or even WebSockets.  It also needs to provide an interface to the store for dealing with asynchronous behavior using something like events, promises, callbacks, generators (<a href="https://github.com/redux-saga/redux-saga" target="_BLANK">sagas</a>), or observables. This is where the connection to the back-end or other services is handled. Additionally the model could provide additional functions related to the data such as hydration of a data set, aggregation of multiple requests, or transformation from a service schema to something more easily digest-able by the store. Every layer above the model is unaware of any specifics regarding details of communication protocols, only the interface provided by the model — making swapping the model code out with a different implementation without affecting the code in the layers above theoretically possible.
          </p>
          <p>
            Because of the possibility for data transformation at the model level I have also marked the model as a layer that could be hosted on a node.js middle-ware server. Most of the discussion these days about server hosted JavaScript middle-layers center around doing an initial render on the server as I mentioned above.  Even if pre-rendering is the use-case with the most obvious benefits I believe the middle-layer can have a place in the service connection. It is essentially a layer between the client and the application server for api communication. It is certainly a more complex process than a direct service call from the client and there would be concerns in terms of network latency, scaling and timeouts. But under the right circumstances it does have the potential benefits of offloading some of the data processing  to a more predictable environment and optimizing the transfer payload between the middle-layer and client. Not all users have the benefit of a fast device on a fast network and many apis cannot be modified for reasons of backwards compatibility or other legacy concerns and may return payloads that are unnecessarily large and bloated, or in a less than optimal format (xml for example). The addition of a transformation, optimization or aggregation layer (which may also implement its own cache of some sort) could be very beneficial in these cases.
          </p>
          <p>
            So in summary the server bootstraps the application and maintains the session (if applicable) and passes primary control over to the client which enforces validations, business logic, and UI state. The client leverages such technologies as client side routing, local storage, fetch and web sockets to keep communications with the server (or other web apis) as streamlined and efficient as possible to insulate the user from the negative effects poor connectivity. It is true that limitations of networking will always have a major impact on any distributed system such as a web application. No amount of client side JavaScript can defeat the realities of network latency and the laws of nature. But with cleaver and well thought out User Interface design and implementation the users can be given an experience that is able to more gracefully deal with these limitations.  This ability to better deal with network link shortcomings along with proving a speedier, more robust UI in general makes the <em>client application stack</em> approach a strong choice for complex pages that require the capabilities of a web application.
          </p>
    </div>
    <div class="col-lg-2  col-md-0 col-xs-0"></div>
  </div>
</article>
<div class="details__arrow">
   <a class="arrow fa fa-arrow-down fa-2x bounce" href="#tech">
    <span class="arrow-meta">Next: <strong>Tech Toolbox</strong></span>
   </a>
</div>