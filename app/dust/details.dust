  <div class="details__content row">
    <div class="col-lg-2 col-md-0"></div>
    <div class="col-lg-4 col-md-12">
      <h2 class="details__heading">
        <span class="details__heading--building">Building</span>{~s}
        <span class="details__heading--modern">the modern</span>{~s}
        <span class="details__heading--client">web client</span>
      </h2>
    </div>
    <div class="col-lg-4 col-md-12 details__body">
      <h3 class="details__model-heading">Steps Forward.</h3>
      <p>
        With ever growing  browser support for html5 standards and the advent of the modern JavaScript ecosystem, it now possible to build web applications that can operate as more than an extension and convenient enhancement to the server. The modern web client can render its own ui, enforce its own business logic, communicate with a large range of services, and in general provide a more responsive user experience that is closer in feel to a native application than a web page. This change in paradigm has transformed the basic nature of the font - end / ui developer role and disrupted the division of responsibilities within the development team.
      </p>
    </div>
      <div class="col-lg-2 col-md-0"></div>
    </div>
    <div class="details__content row">
      <div class="col-lg-2  col-md-0"></div>
      <div class="col-lg-8 col-md-12 details__body">
      <p>
        It is fair to say the role of ui developer is relatively new and has a definition that may still be in flux. In the past, front-end development tasks were simple enough that they were often distributed amongst, or tacked on to, other roles. The designer may create some styling or ui implementations (often generated by design applications such as Dreamweaver), or the server-side application developer might write some JavaScript on top of their other responsibilities. The front-end existed in a sort of ambiguous gray area positioned  between ux/designers on one end and back-end developers on the other.  Over time there emerged a need for a specialist that would focus on hand writing css and creating custom JavaScript that would produce a more functional UI while generating a more maintainable code base.  But the perception that the “serious”, “mission critical” code lives on the server and the front end is essentially disposable is still all too common in the industry.</p><p>While server side technologies are very mature at this point and their role is more or less well defined, front end technologies have been in a period of rapid growth and development for years now.  UI technologies have  started to solidify as a tech that can stand on its own, related to, but separate from any particular server stack.  We have the tools, technologies and the opportunity to create a new web client that is robust enough to deliver a better, more responsive experience to the user.  To achieve this I believe the UI must be treated with the same seriousness and dedication that is given to sever based applications currently.  Operating with the old model is going to become less and less feasible as user expectations continue to grow. We need to end the arbitrary design decisions and lack of process in front end development that is far too common currently.  These new technologies provide an opportunity (and a challenge of course) to advance the experience of using the web for the common, everyday user in a palpable way.
      </p>
    </div>
    <div class="col-lg-2  col-md-0"></div>
  </div>
  <hr class="details__rule">
  <div class="details__content row">
    <div class="col-lg-2  col-md-0 col-xs-0"></div>
    <div class="col-lg-8 col-md-12 details__body">
      <h3 class="details__model-heading">The Client Application Stack</h3>
      <div class="details__col">
        <p>
          Visualizing a new way of thinking about the applications stack were the client has more responsibility is not an entirely simple task. There are so many technologies involved that creating a visualization can easily get unwieldy and become pretty useless. I have done my best to simplify a concept of a basic architecture. Take it for what it is, a concept, not a blueprint.</p><p>The server is still responsible for sending the initial html page to the browser as it must. The page may contain a basic mount point for the front end application or there may be a need for an initial server side rendering for SEO reasons. There is a strong argument to be made for doing an initial render server side, or doing teh app rendering in a middleware layer running node.js server. It allows the page to display initial content before the JavaScript application is downloaded and initialized. This can give the perception to the user that the app has loaded faster. It is also likely the server would be embedding initial bootstrap data for the application to avoid any immediate additional data requests -- also a nice optimization. Ideally, at this point, the server (or middleware) is done producing html. Additional domain interactions would be in the form of api requests using whatever standard is appropriate: REST, SOAP, GraphQL -- whatever the overriding architecture demands.  In the case of an authenticated application, these domain services would also still maintain the session by checking request headers and responding as appropriate when a session expires.</p><p>Once an application has been bootstrapped onto the page it can then use its own internal data store to maintain its state and respond to user interactions, internal events, or subscribed stream events (in the case of the <a href="https://github.com/Reactive-Extensions/RxJS">reactive model</a> -- something I am very excited to learn more about).  The diagram illustrates a data flow that is essentially the <a href="https://facebook.github.io/flux/">Flux</a> pattern were data flows in a single direction. An application event (or <a href="http://redux.js.org/docs/basics/Actions.html">Action</a> ) causes a change in application state which in turn causes the application to re-render its display. Data flows down to the store through event handlers and the state is manipulated there (or a new state is produced if the state is immutable).  The store responsible for transforming the state and passing it back to the view engine.</p><p>Bellow the state layer I have placed the somewhat generic concept of the model. The model is a placeholder for the asynchronous connection  layer that handles making the api requests, or subscribes to event streams using  XMLHttpRequest, Fetch or even WebSockets.  It also needs to prove a interface to the store for dealing with asynchronous behavior using something like events, promises, or callbacks, generators (<a href="http://stackoverflow.com/questions/28489988/svg-takes-up-too-much-space">sagas</a>s&gt;), or observables. This is were the connection to the back-end or other services is handled. Additionally the model could provide additional functions related to the data such as hydration of a data set, aggregation of multiple requests, or transformation from a service schema to something more easily digest-able by the store. Every layer above the model is unaware of any specifics regarding details of communication protocols, only the interface provided by the model -- making swapping the model code out with a different implementation without affecting the code in layer above theoretically possible.
        </p>
        <p>
          Because of the possibility for data transformation at the model level I have also marked the model as a layer that could be hosted on a node.js middleware server. It is quite a bit more complex than the app pre-rendering I mentioned above  and is just a little bit on the bleeding edge(at least for me). The model code would have to exists on both the client and the middle layer so when the store needs to request a resource the client instance of the model would pass a request to the middle layer instance of the model which would in turn make the actual service call, transform the response as needed and pass it back to the client instance which would then resolve the aync request with the response for the store to use in it‘s next state transformation.  It is certainly more complex than a direct service call from the client on the and could have some downsides in terms of network latency and scaling. But it does have the potential to offload some of the data processing  to a more predictable environment. Additionally the response eventually sent back to the client could be optimized to be a lean as possible decreasing the request payload (in theory). Provided that the connection between the middle layer and the server is (ideally) robust and the connection between the middle layer and the client is unknown this could have beneficial effects on slower clients operating on slower network (2g)
        </p>
      </div>
    </div>
  </div>
  <div class="col-lg-2 col-md-0 col-xs-0"></div>
</div>
<div class="details__arrow">
   <a class="arrow fa fa-arrow-down fa-2x bounce" href="#tech"></a>
</div>